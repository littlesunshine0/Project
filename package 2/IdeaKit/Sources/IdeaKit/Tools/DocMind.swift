//
//  DocMind.swift
//  IdeaKit - Project Operating System
//
//  Tool: DocMind
//  Phase: Documentation
//  Purpose: Central documentation brain - cross-link, detect drift, auto-summarize
//  Outputs: docs_index.md, doc_health.json
//

import Foundation

/// Central documentation intelligence system
public final class DocMind: ProjectTool, @unchecked Sendable {
    
    // MARK: - ProjectTool Conformance
    
    public static let id = "doc_mind"
    public static let name = "DocMind"
    public static let description = "Central documentation brain that cross-links specs, tasks, and code"
    public static let phase = ProjectPhase.documentation
    public static let outputs = ["docs_index.md", "doc_health.json"]
    public static let inputs = ["*.md"]
    public static let isDefault = true
    
    // MARK: - Singleton
    
    public static let shared = DocMind()
    private init() {}
    
    // MARK: - State
    
    private var documentIndex: [String: DocumentInfo] = [:]
    private var crossLinks: [CrossLink] = []
    
    // MARK: - Initialization
    
    /// Initialize DocMind for a project context
    public func initialize(context: ProjectContext) async throws {
        // Scan docs folder
        let fm = FileManager.default
        let docsPath = context.docsPath
        
        if fm.fileExists(atPath: docsPath.path) {
            let files = try fm.contentsOfDirectory(at: docsPath, includingPropertiesForKeys: [.contentModificationDateKey])
            
            for file in files where file.pathExtension == "md" {
                let content = try String(contentsOf: file, encoding: .utf8)
                let modDate = try file.resourceValues(forKeys: [.contentModificationDateKey]).contentModificationDate ?? Date()
                
                let info = DocumentInfo(
                    name: file.lastPathComponent,
                    path: file.path,
                    lastModified: modDate,
                    wordCount: content.split(separator: " ").count,
                    sections: extractSections(from: content)
                )
                
                documentIndex[file.lastPathComponent] = info
            }
        }
        
        // Build cross-links
        crossLinks = buildCrossLinks()
    }
    
    /// Generate documentation index
    public func generateIndex(context: ProjectContext) -> String {
        var md = """
        # Documentation Index
        
        _Auto-generated by DocMind_
        
        ## Documents
        
        | Document | Last Modified | Words | Sections |
        |----------|---------------|-------|----------|
        """
        
        for (name, info) in documentIndex.sorted(by: { $0.key < $1.key }) {
            let dateStr = formatDate(info.lastModified)
            md += "\n| [\(name)](\(name)) | \(dateStr) | \(info.wordCount) | \(info.sections.count) |"
        }
        
        md += """
        
        
        ## Cross-References
        
        """
        
        if crossLinks.isEmpty {
            md += "_No cross-references detected_\n"
        } else {
            for link in crossLinks {
                md += "- \(link.source) → \(link.target) (\(link.type))\n"
            }
        }
        
        md += """
        
        ## Document Map
        
        ```
        .ideakit/docs/
        """
        
        for name in documentIndex.keys.sorted() {
            md += "\n├── \(name)"
        }
        
        md += "\n```\n"
        
        return md
    }
    
    /// Analyze documentation health
    public func analyzeHealth(context: ProjectContext) -> DocHealth {
        var health = DocHealth()
        
        // Check for required documents
        let requiredDocs = ["intent.json", "requirements.md", "scope.md", "architecture.md", "tasks.md"]
        health.missingDocs = requiredDocs.filter { !documentIndex.keys.contains($0) && !documentIndex.keys.contains($0.replacingOccurrences(of: ".json", with: ".md")) }
        
        // Check for stale documents (not modified in 7 days)
        let staleThreshold = Date().addingTimeInterval(-7 * 24 * 60 * 60)
        health.staleDocs = documentIndex.filter { $0.value.lastModified < staleThreshold }.map { $0.key }
        
        // Check for orphan documents (no cross-links)
        let linkedDocs = Set(crossLinks.flatMap { [$0.source, $0.target] })
        health.orphanDocs = documentIndex.keys.filter { !linkedDocs.contains($0) }
        
        // Calculate overall score
        let totalDocs = documentIndex.count
        let issues = health.missingDocs.count + health.staleDocs.count + health.orphanDocs.count
        health.score = totalDocs > 0 ? max(0, 100 - (issues * 10)) : 0
        
        return health
    }
    
    /// Generate health report JSON
    public func generateHealthJSON(health: DocHealth) -> [String: Any] {
        [
            "score": health.score,
            "totalDocuments": documentIndex.count,
            "missingDocuments": health.missingDocs,
            "staleDocuments": health.staleDocs,
            "orphanDocuments": health.orphanDocs,
            "crossLinkCount": crossLinks.count,
            "analyzedAt": ISO8601DateFormatter().string(from: Date())
        ]
    }
    
    /// Detect documentation drift
    public func detectDrift(context: ProjectContext) -> [DriftWarning] {
        var warnings: [DriftWarning] = []
        
        // Check if code has changed but docs haven't
        // This is a simplified check - in practice would compare git history
        
        for (name, info) in documentIndex {
            if info.lastModified < Date().addingTimeInterval(-14 * 24 * 60 * 60) {
                warnings.append(DriftWarning(
                    document: name,
                    severity: .medium,
                    message: "Document hasn't been updated in over 2 weeks"
                ))
            }
        }
        
        return warnings
    }
    
    // MARK: - Private Helpers
    
    private func extractSections(from content: String) -> [String] {
        let lines = content.components(separatedBy: "\n")
        return lines.filter { $0.hasPrefix("#") }.map { $0.trimmingCharacters(in: CharacterSet(charactersIn: "# ")) }
    }
    
    private func buildCrossLinks() -> [CrossLink] {
        var links: [CrossLink] = []
        
        // Define known relationships
        let relationships: [(String, String, String)] = [
            ("intent.json", "requirements.md", "generates"),
            ("requirements.md", "scope.md", "defines"),
            ("scope.md", "tasks.md", "decomposes"),
            ("requirements.md", "architecture.md", "informs"),
            ("tasks.md", "milestones.md", "groups")
        ]
        
        for (source, target, type) in relationships {
            if documentIndex.keys.contains(source) || documentIndex.keys.contains(target) {
                links.append(CrossLink(source: source, target: target, type: type))
            }
        }
        
        return links
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: - Supporting Types

public struct DocumentInfo: Sendable {
    public let name: String
    public let path: String
    public let lastModified: Date
    public let wordCount: Int
    public let sections: [String]
}

public struct CrossLink: Sendable {
    public let source: String
    public let target: String
    public let type: String
}

public struct DocHealth: Sendable {
    public var score: Int = 100
    public var missingDocs: [String] = []
    public var staleDocs: [String] = []
    public var orphanDocs: [String] = []
    
    public init() {}
}

public struct DriftWarning: Sendable {
    public let document: String
    public let severity: DriftSeverity
    public let message: String
}

public enum DriftSeverity: String, Sendable {
    case low, medium, high, critical
}
